from itertools import permutations, combinations
from collections import deque

def n_k(n, k):
  """
  permutations of n with no repetitions
  """
  return permutations(range(n), k)

def combine(x, y, z):
  return x + y + z

def swap(element, res):

  for x in permutations(element[0], len(element[0])):
    for y in permutations(element[1], len(element[1])):
      for z in permutations(element[2], len(element[2])):
        res.add(combine(x, y, z))

# breaks down a permutation into sizes of 3, 3, and 4
def generate_eq_class(element):

  res = set()

  a = element[:3]
  b = element[3:6]
  c = element[6:]

  print(len(a), len(b), len(c))
  print("number of block permutations is: %d" % len(list(permutations([a, b, c], 3))))

  for x in permutations([a, b, c], 3):
    swap(x, res)

  return res

def rotations(n):
  """
  returns the permutations generated by
  rotating permutation n
  """
  p = deque(n)
  res = set()

  for times in range(len(n)):
    p.rotate()
    res.add(tuple(p))

  return res

def flip(p):
  """
  Takes a permutation p and performs a flip
  """
  n = len(p) // 2
  rest = list(p[1:]) # slicing copies the list
  for i in range(0, n):
    rest[i], rest[-(i + 1)] = rest[-(i + 1)], rest[i] # swap elements in list

  return (p[0],) + tuple(rest)

def necklaces(n):
  """
  returns the seed necklaces
  equivalent under permutations and flips
  (These necklaces belong in different eq classes
   and can further generate more necklaces belonging
   to different eq classes by permuting the remaining
   n-3 elements)

  n is a permutation of integers (list)
  """
  universe = set(n)
  length = len(n)

  # get neighbors around the first element
  first = [n[0]]
  others = set(n).difference(first)
  neighbors = list(combinations(others, 2)) # (n-1) choose 2 neighbors

  seeds = set()

  for left, right in neighbors:
    left_neighbor = [left]
    right_neighbor = [right]

    rest = universe.difference(first + right_neighbor + left_neighbor)
    p = tuple(first + right_neighbor + list(rest) + left_neighbor)
    seeds.add(p)

  return seeds

def enumerate_necklaces(seeds):
  """
  returns the neckalces generated from seeds
  TODO: consider making a generator
  """

  result = set()
  generated_seeds = set()

  for i in seeds:
    first, right_neighbor, left_neighbor = [i[0]], [i[1]], [i[-1]]

    # get the generated seeds
    # TODO: this will not run for len(seeds) <= 2
    for j in permutations(i[2:-1], len(i) - 3):
      p = tuple(first + right_neighbor + list(j) + left_neighbor)
      generated_seeds.add(p)

  all_seeds = seeds.union(generated_seeds)
  all_flips = set()

  # get each seeds flips
  for i in all_seeds:
    all_flips.add(i)
    all_flips.add(flip(i))

  # get all rotations
  for i in all_flips:
    result.add(i)
    result = result.union(rotations(i))

  return result

if __name__ == '__main__':

  universe = list(n_k(10, 10))
  print(universe[0])
  eq_class = generate_eq_class(universe[0])
  print(len(eq_class))
  print(6 * 6 * 6 * 4 * 3 * 2)

  ######### necklaces
  print(necklaces(list(range(1, 6))))
  print(enumerate_necklaces(necklaces(list(range(1, 6)))))
  print(len(enumerate_necklaces(necklaces(list(range(1, 6))))))
